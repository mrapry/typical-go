package typreadme

import (
	"fmt"
	"io"

	"github.com/iancoleman/strcase"
	"github.com/typical-go/typical-go/pkg/typicmd/buildtool"
	"github.com/typical-go/typical-go/pkg/typictx"
	"github.com/typical-go/typical-go/pkg/typimodule"
	"github.com/typical-go/typical-go/pkg/typreadme/markdown"
)

// Generator is responsible to generate readme
type Generator struct{}

// Generate readme
func (Generator) Generate(ctx *typictx.Context, w io.Writer) (err error) {
	md := &markdown.Markdown{Writer: w}
	md.Comment("Autogenerated by Typical-Go. DO NOT EDIT.")
	if ctx.Name != "" {
		md.H1(ctx.Name)
	} else {
		md.H1("Typical-Go Project")
	}
	if ctx.Description != "" {
		md.Writeln(ctx.Description)
	}
	md.H2("Prerequisite")
	prerequisite(md)
	md.H2("Build")
	runInstruction(md)
	md.H2("Application")
	application(md, ctx.AppModule)
	md.H2("Modules")
	for _, m := range ctx.Modules {
		module(md, m)
	}
	md.H2("Release Distribution")
	releaseDistribution(md)
	return
}

func prerequisite(md *markdown.Markdown) {
	md.OrderedList(
		"[Go](https://golang.org/doc/install) (It is recommend to install via [Homebrew](https://brew.sh/) `brew install go`)",
	)
}

func runInstruction(md *markdown.Markdown) {
	md.Writeln("Use `./typicalw build` to build the project.")
	md.Writeln("Use `./typicalw run` to build and run the project.")
	md.Writeln("Use `./typicalw test` to execute the unit testing.")
	md.Writeln("Learn more about [Build Tool](https://typical-go.github.io/learn-more/build-tool)")
}

func releaseDistribution(md *markdown.Markdown) {
	md.Writeln("Use `./typicalw release` to make the release. You can find the binary at `release` folder.")
	md.Writeln("Learn more [Release Distribution](https://typical-go.github.io/learn-more/build-tool/release-distribution.html)")
}

func application(md *markdown.Markdown, app interface{}) {
	if configurer, ok := app.(typimodule.Configurer); ok {
		configTable(md, configurer.Configure().ConfigFields())
	}
}

func module(md *markdown.Markdown, module interface{}) {
	if name := typimodule.Name(module); name != "" {
		md.H3(strcase.ToCamel(name))
	}
	if description := typimodule.Description(module); description != "" {
		md.Writeln(description)
	}
	if configurer, ok := module.(typimodule.Configurer); ok {
		configTable(md, configurer.Configure().ConfigFields())
	}
	cmd := buildtool.Command(nil, module)
	if cmd != nil && len(cmd.Subcommands) > 0 {
		md.WriteString("Commands:\n")
		var cmdHelps []string
		for _, subcmd := range cmd.Subcommands {
			cmdHelps = append(cmdHelps,
				fmt.Sprintf("`./typicalw %s %s`: %s", cmd.Name, subcmd.Name, subcmd.Usage))
		}
		md.UnorderedList(cmdHelps...)
	}
}

func configTable(md *markdown.Markdown, fields []typimodule.ConfigField) {
	md.WriteString("| Name | Type | Default | Required |\n")
	md.WriteString("|---|---|---|:---:|\n")
	for _, field := range fields {
		var required string
		if field.Required {
			required = "Yes"
		}
		md.WriteString(fmt.Sprintf("|%s|%s|%s|%s|\n",
			field.Name, field.Type, field.Default, required))
	}
	md.WriteString("\n")
}
