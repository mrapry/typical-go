package typgo_test

import (
	"io/ioutil"
	"os"
	"testing"

	"github.com/stretchr/testify/require"
	"github.com/typical-go/typical-go/pkg/typgo"
)

func TestConfigManager_GetTarget(t *testing.T) {
	testcases := []struct {
		TestName string
		*typgo.ConfigManager
		Context  *typgo.Context
		Expected string
	}{
		{
			TestName:      "initial target is not set",
			ConfigManager: &typgo.ConfigManager{},
			Context: &typgo.Context{
				BuildCli: &typgo.BuildCli{
					Descriptor: &typgo.Descriptor{Name: "name0"},
				},
			},
			Expected: "cmd/name0/config_annotated.go",
		},
		{
			TestName: "initial target is set",
			ConfigManager: &typgo.ConfigManager{
				Target: "some-target",
			},
			Expected: "some-target",
		},
	}
	for _, tt := range testcases {
		t.Run(tt.TestName, func(t *testing.T) {
			require.Equal(t, tt.Expected, tt.GetTarget(tt.Context))
		})
	}
}

func TestConfigManager_Execute(t *testing.T) {
	type sample struct {
		Field1 string `default:"some-text"`
		Field2 int    `default:"9876"`
	}
	target := "some-target"
	defer os.Remove(target)
	defer os.Remove(typgo.EnvFile)
	ctorAnnot := &typgo.ConfigManager{
		Target: target,
		Configs: []*typgo.Configuration{
			{Name: "SAMPLE", Spec: &sample{}},
		},
		EnvFile: true,
	}
	ctx := &typgo.Context{
		BuildCli: &typgo.BuildCli{},
	}

	require.NoError(t, ctorAnnot.Execute(ctx))

	b, _ := ioutil.ReadFile(target)
	require.Equal(t, []byte(`package main

// Autogenerated by Typical-Go. DO NOT EDIT.

import (
)

func init() { 
	typapp.Provide(
		&typapp.Constructor{
			Name: "",
			Fn: func() (cfg *typgo_test.sample, err error) {
				cfg = new(typgo_test.sample)
				if err = typgo.ProcessConfig("SAMPLE", cfg); err != nil {
					return nil, err
				}
				return
			},
		},
	)
}`), b)

	b, _ = ioutil.ReadFile(typgo.EnvFile)
	require.Equal(t, []byte("SAMPLE_FIELD1=some-text\nSAMPLE_FIELD2=9876\n"), b)
}
